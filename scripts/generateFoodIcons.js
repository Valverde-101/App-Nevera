const fs = require('fs');
const path = require('path');

const root = path.join(__dirname, '..');
// Directory where all the icon assets live. In this repository the icons
// directory sits at the project root rather than inside the Expo project.
const iconsDir = path.join(root, 'icons');
// Target file inside the Expo project where the generated mapping will be
// written.
const targetFile = path.join(root, 'MiAppNevera', 'src', 'foodIcons.js');

function normalize(name) {
  return name
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-z0-9]/g, '');
}

// Capitalize the first letter of each word, supporting Unicode characters.
function toTitleCase(str) {
  return str.replace(/\p{L}+/gu, word =>
    word.charAt(0).toUpperCase() + word.slice(1)
  );
}

// Load metadata (display names and expiration days) from foodConfig.json if present.
const metaPath = path.join(__dirname, 'foodConfig.json');
let metadata = {};
if (fs.existsSync(metaPath)) {
  metadata = JSON.parse(fs.readFileSync(metaPath, 'utf8'));
}

// Store every individual food icon, the icon for each category and the mapping
// from categories to the food names that belong to them.
const entries = [];
// Store metadata for category icons: path and original base name for display.
const categoryIcons = {};
const categoryItems = {};

function walk(dir) {
  fs.readdirSync(dir).forEach(entry => {
    const full = path.join(dir, entry);
    const stat = fs.statSync(full);
    if (stat.isDirectory()) {
      walk(full);
    } else {
      // Path to use inside the generated file (relative to src).
      const rel = path
        .relative(path.join(root, 'MiAppNevera', 'src'), full)
        .replace(/\\/g, '/');

      // Normalised base name without the `_icon` suffix.
      let base = path.basename(entry, path.extname(entry));
      base = base.replace(/_icon.*$/, '').replace(/[-_]/g, ' ');
      const key = normalize(base);

      // Determine the top-level directory inside icons/ to infer the category.
      const parts = path.relative(iconsDir, full).split(path.sep);
      const category = normalize(parts[0]);

      if (category === 'categorias') {
        // These files are the icons that represent each category itself.
        categoryIcons[key] = { rel, base };
      } else {
        // Regular food icon. Track it and associate it with its category.
        entries.push({ key, rel, base });
        categoryItems[category] = categoryItems[category] || [];
        categoryItems[category].push(key);
      }
    }
  });
}

walk(iconsDir);

// Sort entries for deterministic output and de-duplicate items inside each
// category.
entries.sort((a, b) => a.key.localeCompare(b.key));
for (const cat of Object.keys(categoryItems)) {
  categoryItems[cat] = Array.from(new Set(categoryItems[cat])).sort();
}

const lines = [];
lines.push('// This file is auto-generated by scripts/generateFoodIcons.js');
lines.push('export const foodData = {');

const seen = new Set();
for (const { key, rel, base } of entries) {
  if (!seen.has(key)) {
    const cfg = metadata[key] || {};
    const displayName = cfg.name || toTitleCase(base);
    const exp = cfg.expirationDays != null ? cfg.expirationDays : null;
    lines.push(`  '${key}': {`);
    lines.push(`    icon: require('./${rel}'),`);
    lines.push(`    name: '${displayName.replace(/'/g, "\\'")}',`);
    lines.push(`    expirationDays: ${exp === null ? 'null' : exp},`);
    lines.push('  },');
    seen.add(key);
  }
}

lines.push('};');
lines.push('');
lines.push('export const foodIcons = Object.fromEntries(');
lines.push('  Object.entries(foodData).map(([k, v]) => [k, v.icon])');
lines.push(');');
lines.push('');

// Generate category information with icon and list of food names.
lines.push('export const categories = {');
const allCategories = new Set([
  ...Object.keys(categoryIcons),
  ...Object.keys(categoryItems),
]);
for (const cat of Array.from(allCategories).sort()) {
  const iconData = categoryIcons[cat];
  const icon = iconData && iconData.rel;
  const baseName = iconData ? iconData.base : cat;
  const displayName = toTitleCase(baseName);
  const items = categoryItems[cat] || [];
  lines.push(`  '${cat}': {`);
  lines.push(
    icon
      ? `    icon: require('./${icon}'),`
      : '    icon: null,'
  );
  lines.push(`    name: '${displayName.replace(/'/g, "\\'")}',`);
  lines.push(`    items: [${items.map(i => `'${i}'`).join(', ')}],`);
  lines.push('  },');
}
lines.push('};');
lines.push('');

lines.push('export function normalizeFoodName(name) {');
lines.push("  return name.toLowerCase().normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').replace(/[^a-z0-9]/g, '');");
lines.push('}');
lines.push('');

lines.push('export function getFoodInfo(name) {');
lines.push('  return foodData[normalizeFoodName(name)];');
lines.push('}');
lines.push('');

lines.push('export function getFoodIcon(name) {');
lines.push('  const info = getFoodInfo(name);');
lines.push('  return info ? info.icon : undefined;');
lines.push('}');
lines.push('');

lines.push('export function getFoodCategory(name) {');
lines.push('  const normalized = normalizeFoodName(name);');
lines.push('  for (const [cat, data] of Object.entries(categories)) {');
lines.push('    if (data.items.includes(normalized)) {');
lines.push('      return cat;');
lines.push('    }');
lines.push('  }');
lines.push('  return null;');
lines.push('}');
lines.push('');

lines.push('export default foodIcons;');

fs.writeFileSync(targetFile, lines.join('\n'));
